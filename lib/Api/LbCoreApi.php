<?php
/**
 * LbCoreApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * ListenBrainz Swagger - OpenAPI 3.0
 *
 * OpenAPI client defintion.
 *
 * The version of the OpenAPI document: v-2024-07-17.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Listenbrainz\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * LbCoreApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class LbCoreApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'deleteListen' => [
            'application/json',
        ],
        'latestImport' => [
            'application/json',
        ],
        'lbRadioRecordingsForArtist' => [
            'application/json',
        ],
        'lbRadioTags' => [
            'application/json',
        ],
        'listenCountForUser' => [
            'application/json',
        ],
        'listensForUser' => [
            'application/json',
        ],
        'playingNowForUser' => [
            'application/json',
        ],
        'recommendationPlaylistsForUser' => [
            'application/json',
        ],
        'searchPlaylistForUser' => [
            'application/json',
        ],
        'searchUsers' => [
            'application/json',
        ],
        'servicesForUser' => [
            'application/json',
        ],
        'similarUsersForUser' => [
            'application/json',
        ],
        'similarityOfUserForUser' => [
            'application/json',
        ],
        'submitListens' => [
            'application/json',
        ],
        'validateToken' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteListen
     *
     * Delete a particular listen from a user&#39;s listen history.
     *
     * @param  \OpenAPI\Client\Model\DeleteListen $delete_listen delete_listen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListen'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteListen($delete_listen, string $contentType = self::contentTypes['deleteListen'][0])
    {
        $this->deleteListenWithHttpInfo($delete_listen, $contentType);
    }

    /**
     * Operation deleteListenWithHttpInfo
     *
     * Delete a particular listen from a user&#39;s listen history.
     *
     * @param  \OpenAPI\Client\Model\DeleteListen $delete_listen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListen'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteListenWithHttpInfo($delete_listen, string $contentType = self::contentTypes['deleteListen'][0])
    {
        $request = $this->deleteListenRequest($delete_listen, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteListenAsync
     *
     * Delete a particular listen from a user&#39;s listen history.
     *
     * @param  \OpenAPI\Client\Model\DeleteListen $delete_listen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListenAsync($delete_listen, string $contentType = self::contentTypes['deleteListen'][0])
    {
        return $this->deleteListenAsyncWithHttpInfo($delete_listen, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteListenAsyncWithHttpInfo
     *
     * Delete a particular listen from a user&#39;s listen history.
     *
     * @param  \OpenAPI\Client\Model\DeleteListen $delete_listen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteListenAsyncWithHttpInfo($delete_listen, string $contentType = self::contentTypes['deleteListen'][0])
    {
        $returnType = '';
        $request = $this->deleteListenRequest($delete_listen, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteListen'
     *
     * @param  \OpenAPI\Client\Model\DeleteListen $delete_listen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteListen'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteListenRequest($delete_listen, string $contentType = self::contentTypes['deleteListen'][0])
    {

        // verify the required parameter 'delete_listen' is set
        if ($delete_listen === null || (is_array($delete_listen) && count($delete_listen) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delete_listen when calling deleteListen'
            );
        }


        $resourcePath = '/1/delete-listen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($delete_listen)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($delete_listen));
            } else {
                $httpBody = $delete_listen;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation latestImport
     *
     * Get the timestamp of the newest listen submitted by a user in previous imports to ListenBrainz.
     *
     * @param  string $user_name The MusicBrainz ID of the user whose data is needed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['latestImport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LatestImport
     */
    public function latestImport($user_name, string $contentType = self::contentTypes['latestImport'][0])
    {
        list($response) = $this->latestImportWithHttpInfo($user_name, $contentType);
        return $response;
    }

    /**
     * Operation latestImportWithHttpInfo
     *
     * Get the timestamp of the newest listen submitted by a user in previous imports to ListenBrainz.
     *
     * @param  string $user_name The MusicBrainz ID of the user whose data is needed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['latestImport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LatestImport, HTTP status code, HTTP response headers (array of strings)
     */
    public function latestImportWithHttpInfo($user_name, string $contentType = self::contentTypes['latestImport'][0])
    {
        $request = $this->latestImportRequest($user_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\LatestImport' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\LatestImport' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\LatestImport', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\LatestImport';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LatestImport',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation latestImportAsync
     *
     * Get the timestamp of the newest listen submitted by a user in previous imports to ListenBrainz.
     *
     * @param  string $user_name The MusicBrainz ID of the user whose data is needed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['latestImport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function latestImportAsync($user_name, string $contentType = self::contentTypes['latestImport'][0])
    {
        return $this->latestImportAsyncWithHttpInfo($user_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation latestImportAsyncWithHttpInfo
     *
     * Get the timestamp of the newest listen submitted by a user in previous imports to ListenBrainz.
     *
     * @param  string $user_name The MusicBrainz ID of the user whose data is needed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['latestImport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function latestImportAsyncWithHttpInfo($user_name, string $contentType = self::contentTypes['latestImport'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LatestImport';
        $request = $this->latestImportRequest($user_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'latestImport'
     *
     * @param  string $user_name The MusicBrainz ID of the user whose data is needed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['latestImport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function latestImportRequest($user_name, string $contentType = self::contentTypes['latestImport'][0])
    {

        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling latestImport'
            );
        }


        $resourcePath = '/1/latest-import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_name,
            'user_name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lbRadioRecordingsForArtist
     *
     * Get recordings for use in LB radio with the given seed artist. The endpoint returns a dict of all the similar artists, including the seed artist. For each artists, there will be a list of dicts that contain recording_mbid, similar_artist_mbid and total_listen_count.
     *
     * @param  string $seed_artist_mbid seed_artist_mbid (required)
     * @param  \OpenAPI\Client\Model\Mode $mode The mode that LB radio should use. Must be easy, medium or hard. (required)
     * @param  int $max_similar_artists The maximum number of similar artists to return recordings for. (required)
     * @param  int $max_recordings_per_artist The maximum number of recordings to return for each artist. If there are aren’t enough recordings, all available recordings will be returned. (required)
     * @param  int $pop_begin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes. (required)
     * @param  int $pop_end Popularity range percentage upper bound. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lbRadioRecordingsForArtist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,\OpenAPI\Client\Model\LbRadioRecordingsForArtistValueInner[]>
     */
    public function lbRadioRecordingsForArtist($seed_artist_mbid, $mode, $max_similar_artists, $max_recordings_per_artist, $pop_begin, $pop_end, string $contentType = self::contentTypes['lbRadioRecordingsForArtist'][0])
    {
        list($response) = $this->lbRadioRecordingsForArtistWithHttpInfo($seed_artist_mbid, $mode, $max_similar_artists, $max_recordings_per_artist, $pop_begin, $pop_end, $contentType);
        return $response;
    }

    /**
     * Operation lbRadioRecordingsForArtistWithHttpInfo
     *
     * Get recordings for use in LB radio with the given seed artist. The endpoint returns a dict of all the similar artists, including the seed artist. For each artists, there will be a list of dicts that contain recording_mbid, similar_artist_mbid and total_listen_count.
     *
     * @param  string $seed_artist_mbid (required)
     * @param  \OpenAPI\Client\Model\Mode $mode The mode that LB radio should use. Must be easy, medium or hard. (required)
     * @param  int $max_similar_artists The maximum number of similar artists to return recordings for. (required)
     * @param  int $max_recordings_per_artist The maximum number of recordings to return for each artist. If there are aren’t enough recordings, all available recordings will be returned. (required)
     * @param  int $pop_begin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes. (required)
     * @param  int $pop_end Popularity range percentage upper bound. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lbRadioRecordingsForArtist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,\OpenAPI\Client\Model\LbRadioRecordingsForArtistValueInner[]>, HTTP status code, HTTP response headers (array of strings)
     */
    public function lbRadioRecordingsForArtistWithHttpInfo($seed_artist_mbid, $mode, $max_similar_artists, $max_recordings_per_artist, $pop_begin, $pop_end, string $contentType = self::contentTypes['lbRadioRecordingsForArtist'][0])
    {
        $request = $this->lbRadioRecordingsForArtistRequest($seed_artist_mbid, $mode, $max_similar_artists, $max_recordings_per_artist, $pop_begin, $pop_end, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('array<string,\OpenAPI\Client\Model\LbRadioRecordingsForArtistValueInner[]>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,\OpenAPI\Client\Model\LbRadioRecordingsForArtistValueInner[]>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,\OpenAPI\Client\Model\LbRadioRecordingsForArtistValueInner[]>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'array<string,\OpenAPI\Client\Model\LbRadioRecordingsForArtistValueInner[]>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,\OpenAPI\Client\Model\LbRadioRecordingsForArtistValueInner[]>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lbRadioRecordingsForArtistAsync
     *
     * Get recordings for use in LB radio with the given seed artist. The endpoint returns a dict of all the similar artists, including the seed artist. For each artists, there will be a list of dicts that contain recording_mbid, similar_artist_mbid and total_listen_count.
     *
     * @param  string $seed_artist_mbid (required)
     * @param  \OpenAPI\Client\Model\Mode $mode The mode that LB radio should use. Must be easy, medium or hard. (required)
     * @param  int $max_similar_artists The maximum number of similar artists to return recordings for. (required)
     * @param  int $max_recordings_per_artist The maximum number of recordings to return for each artist. If there are aren’t enough recordings, all available recordings will be returned. (required)
     * @param  int $pop_begin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes. (required)
     * @param  int $pop_end Popularity range percentage upper bound. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lbRadioRecordingsForArtist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lbRadioRecordingsForArtistAsync($seed_artist_mbid, $mode, $max_similar_artists, $max_recordings_per_artist, $pop_begin, $pop_end, string $contentType = self::contentTypes['lbRadioRecordingsForArtist'][0])
    {
        return $this->lbRadioRecordingsForArtistAsyncWithHttpInfo($seed_artist_mbid, $mode, $max_similar_artists, $max_recordings_per_artist, $pop_begin, $pop_end, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lbRadioRecordingsForArtistAsyncWithHttpInfo
     *
     * Get recordings for use in LB radio with the given seed artist. The endpoint returns a dict of all the similar artists, including the seed artist. For each artists, there will be a list of dicts that contain recording_mbid, similar_artist_mbid and total_listen_count.
     *
     * @param  string $seed_artist_mbid (required)
     * @param  \OpenAPI\Client\Model\Mode $mode The mode that LB radio should use. Must be easy, medium or hard. (required)
     * @param  int $max_similar_artists The maximum number of similar artists to return recordings for. (required)
     * @param  int $max_recordings_per_artist The maximum number of recordings to return for each artist. If there are aren’t enough recordings, all available recordings will be returned. (required)
     * @param  int $pop_begin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes. (required)
     * @param  int $pop_end Popularity range percentage upper bound. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lbRadioRecordingsForArtist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lbRadioRecordingsForArtistAsyncWithHttpInfo($seed_artist_mbid, $mode, $max_similar_artists, $max_recordings_per_artist, $pop_begin, $pop_end, string $contentType = self::contentTypes['lbRadioRecordingsForArtist'][0])
    {
        $returnType = 'array<string,\OpenAPI\Client\Model\LbRadioRecordingsForArtistValueInner[]>';
        $request = $this->lbRadioRecordingsForArtistRequest($seed_artist_mbid, $mode, $max_similar_artists, $max_recordings_per_artist, $pop_begin, $pop_end, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lbRadioRecordingsForArtist'
     *
     * @param  string $seed_artist_mbid (required)
     * @param  \OpenAPI\Client\Model\Mode $mode The mode that LB radio should use. Must be easy, medium or hard. (required)
     * @param  int $max_similar_artists The maximum number of similar artists to return recordings for. (required)
     * @param  int $max_recordings_per_artist The maximum number of recordings to return for each artist. If there are aren’t enough recordings, all available recordings will be returned. (required)
     * @param  int $pop_begin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes. (required)
     * @param  int $pop_end Popularity range percentage upper bound. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lbRadioRecordingsForArtist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lbRadioRecordingsForArtistRequest($seed_artist_mbid, $mode, $max_similar_artists, $max_recordings_per_artist, $pop_begin, $pop_end, string $contentType = self::contentTypes['lbRadioRecordingsForArtist'][0])
    {

        // verify the required parameter 'seed_artist_mbid' is set
        if ($seed_artist_mbid === null || (is_array($seed_artist_mbid) && count($seed_artist_mbid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $seed_artist_mbid when calling lbRadioRecordingsForArtist'
            );
        }

        // verify the required parameter 'mode' is set
        if ($mode === null || (is_array($mode) && count($mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mode when calling lbRadioRecordingsForArtist'
            );
        }

        // verify the required parameter 'max_similar_artists' is set
        if ($max_similar_artists === null || (is_array($max_similar_artists) && count($max_similar_artists) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $max_similar_artists when calling lbRadioRecordingsForArtist'
            );
        }

        // verify the required parameter 'max_recordings_per_artist' is set
        if ($max_recordings_per_artist === null || (is_array($max_recordings_per_artist) && count($max_recordings_per_artist) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $max_recordings_per_artist when calling lbRadioRecordingsForArtist'
            );
        }

        // verify the required parameter 'pop_begin' is set
        if ($pop_begin === null || (is_array($pop_begin) && count($pop_begin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pop_begin when calling lbRadioRecordingsForArtist'
            );
        }

        // verify the required parameter 'pop_end' is set
        if ($pop_end === null || (is_array($pop_end) && count($pop_end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pop_end when calling lbRadioRecordingsForArtist'
            );
        }


        $resourcePath = '/1/lb-radio/artist/{seed_artist_mbid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mode,
            'mode', // param base name
            'Mode', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_similar_artists,
            'max_similar_artists', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_recordings_per_artist,
            'max_recordings_per_artist', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pop_begin,
            'pop_begin', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pop_end,
            'pop_end', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);


        // path params
        if ($seed_artist_mbid !== null) {
            $resourcePath = str_replace(
                '{' . 'seed_artist_mbid' . '}',
                ObjectSerializer::toPathValue($seed_artist_mbid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lbRadioTags
     *
     * Get recordings for use in LB radio with the specified tags that match the requested criteria.
     *
     * @param  string $tag The MusicBrainz tag to fetch recordings for, this parameter can be specified multiple times. if more than one tag is specified, the operator param should also be specified. (required)
     * @param  int $pop_begin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes. (required)
     * @param  int $pop_end Popularity range percentage upper bound. (required)
     * @param  int $count Optional, number of listens to return. (required)
     * @param  \OpenAPI\Client\Model\Operator|null $operator Specify AND to retrieve recordings that have all the tags, otherwise specify OR to retrieve recordings that have any one of the tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lbRadioTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\LbRadioTagsInner[]
     */
    public function lbRadioTags($tag, $pop_begin, $pop_end, $count, $operator = null, string $contentType = self::contentTypes['lbRadioTags'][0])
    {
        list($response) = $this->lbRadioTagsWithHttpInfo($tag, $pop_begin, $pop_end, $count, $operator, $contentType);
        return $response;
    }

    /**
     * Operation lbRadioTagsWithHttpInfo
     *
     * Get recordings for use in LB radio with the specified tags that match the requested criteria.
     *
     * @param  string $tag The MusicBrainz tag to fetch recordings for, this parameter can be specified multiple times. if more than one tag is specified, the operator param should also be specified. (required)
     * @param  int $pop_begin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes. (required)
     * @param  int $pop_end Popularity range percentage upper bound. (required)
     * @param  int $count Optional, number of listens to return. (required)
     * @param  \OpenAPI\Client\Model\Operator|null $operator Specify AND to retrieve recordings that have all the tags, otherwise specify OR to retrieve recordings that have any one of the tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lbRadioTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\LbRadioTagsInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function lbRadioTagsWithHttpInfo($tag, $pop_begin, $pop_end, $count, $operator = null, string $contentType = self::contentTypes['lbRadioTags'][0])
    {
        $request = $this->lbRadioTagsRequest($tag, $pop_begin, $pop_end, $count, $operator, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\LbRadioTagsInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\LbRadioTagsInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\LbRadioTagsInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\LbRadioTagsInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\LbRadioTagsInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lbRadioTagsAsync
     *
     * Get recordings for use in LB radio with the specified tags that match the requested criteria.
     *
     * @param  string $tag The MusicBrainz tag to fetch recordings for, this parameter can be specified multiple times. if more than one tag is specified, the operator param should also be specified. (required)
     * @param  int $pop_begin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes. (required)
     * @param  int $pop_end Popularity range percentage upper bound. (required)
     * @param  int $count Optional, number of listens to return. (required)
     * @param  \OpenAPI\Client\Model\Operator|null $operator Specify AND to retrieve recordings that have all the tags, otherwise specify OR to retrieve recordings that have any one of the tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lbRadioTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lbRadioTagsAsync($tag, $pop_begin, $pop_end, $count, $operator = null, string $contentType = self::contentTypes['lbRadioTags'][0])
    {
        return $this->lbRadioTagsAsyncWithHttpInfo($tag, $pop_begin, $pop_end, $count, $operator, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lbRadioTagsAsyncWithHttpInfo
     *
     * Get recordings for use in LB radio with the specified tags that match the requested criteria.
     *
     * @param  string $tag The MusicBrainz tag to fetch recordings for, this parameter can be specified multiple times. if more than one tag is specified, the operator param should also be specified. (required)
     * @param  int $pop_begin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes. (required)
     * @param  int $pop_end Popularity range percentage upper bound. (required)
     * @param  int $count Optional, number of listens to return. (required)
     * @param  \OpenAPI\Client\Model\Operator|null $operator Specify AND to retrieve recordings that have all the tags, otherwise specify OR to retrieve recordings that have any one of the tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lbRadioTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lbRadioTagsAsyncWithHttpInfo($tag, $pop_begin, $pop_end, $count, $operator = null, string $contentType = self::contentTypes['lbRadioTags'][0])
    {
        $returnType = '\OpenAPI\Client\Model\LbRadioTagsInner[]';
        $request = $this->lbRadioTagsRequest($tag, $pop_begin, $pop_end, $count, $operator, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lbRadioTags'
     *
     * @param  string $tag The MusicBrainz tag to fetch recordings for, this parameter can be specified multiple times. if more than one tag is specified, the operator param should also be specified. (required)
     * @param  int $pop_begin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes. (required)
     * @param  int $pop_end Popularity range percentage upper bound. (required)
     * @param  int $count Optional, number of listens to return. (required)
     * @param  \OpenAPI\Client\Model\Operator|null $operator Specify AND to retrieve recordings that have all the tags, otherwise specify OR to retrieve recordings that have any one of the tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lbRadioTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lbRadioTagsRequest($tag, $pop_begin, $pop_end, $count, $operator = null, string $contentType = self::contentTypes['lbRadioTags'][0])
    {

        // verify the required parameter 'tag' is set
        if ($tag === null || (is_array($tag) && count($tag) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tag when calling lbRadioTags'
            );
        }

        // verify the required parameter 'pop_begin' is set
        if ($pop_begin === null || (is_array($pop_begin) && count($pop_begin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pop_begin when calling lbRadioTags'
            );
        }

        // verify the required parameter 'pop_end' is set
        if ($pop_end === null || (is_array($pop_end) && count($pop_end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pop_end when calling lbRadioTags'
            );
        }

        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling lbRadioTags'
            );
        }



        $resourcePath = '/1/lb-radio/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tag,
            'tag', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $operator,
            'operator', // param base name
            'Operator', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pop_begin,
            'pop_begin', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pop_end,
            'pop_end', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listenCountForUser
     *
     * Get the number of listens for a user &#39;user_name&#39;.
     *
     * @param  string $user_name user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listenCountForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListenCountForUser
     */
    public function listenCountForUser($user_name, string $contentType = self::contentTypes['listenCountForUser'][0])
    {
        list($response) = $this->listenCountForUserWithHttpInfo($user_name, $contentType);
        return $response;
    }

    /**
     * Operation listenCountForUserWithHttpInfo
     *
     * Get the number of listens for a user &#39;user_name&#39;.
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listenCountForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListenCountForUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function listenCountForUserWithHttpInfo($user_name, string $contentType = self::contentTypes['listenCountForUser'][0])
    {
        $request = $this->listenCountForUserRequest($user_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListenCountForUser' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListenCountForUser' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListenCountForUser', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListenCountForUser';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListenCountForUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listenCountForUserAsync
     *
     * Get the number of listens for a user &#39;user_name&#39;.
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listenCountForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listenCountForUserAsync($user_name, string $contentType = self::contentTypes['listenCountForUser'][0])
    {
        return $this->listenCountForUserAsyncWithHttpInfo($user_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listenCountForUserAsyncWithHttpInfo
     *
     * Get the number of listens for a user &#39;user_name&#39;.
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listenCountForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listenCountForUserAsyncWithHttpInfo($user_name, string $contentType = self::contentTypes['listenCountForUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListenCountForUser';
        $request = $this->listenCountForUserRequest($user_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listenCountForUser'
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listenCountForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listenCountForUserRequest($user_name, string $contentType = self::contentTypes['listenCountForUser'][0])
    {

        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling listenCountForUser'
            );
        }


        $resourcePath = '/1/user/{user_name}/listen-count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'user_name' . '}',
                ObjectSerializer::toPathValue($user_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listensForUser
     *
     * Get listens for user &#39;user_name&#39;.
     *
     * @param  string $user_name user_name (required)
     * @param  int|null $max_ts If you specify a &#39;max_ts&#39; timestamp, listens with listened_at less than (but not including) this value will be returned. (optional)
     * @param  int|null $min_ts If you specify a &#39;min_ts&#39; timestamp, listens with listened_at greater than (but not including) this value will be returned. (optional)
     * @param  int|null $count Optional, number of listens to return. (optional, default to 25)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listensForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListensForUser
     */
    public function listensForUser($user_name, $max_ts = null, $min_ts = null, $count = 25, string $contentType = self::contentTypes['listensForUser'][0])
    {
        list($response) = $this->listensForUserWithHttpInfo($user_name, $max_ts, $min_ts, $count, $contentType);
        return $response;
    }

    /**
     * Operation listensForUserWithHttpInfo
     *
     * Get listens for user &#39;user_name&#39;.
     *
     * @param  string $user_name (required)
     * @param  int|null $max_ts If you specify a &#39;max_ts&#39; timestamp, listens with listened_at less than (but not including) this value will be returned. (optional)
     * @param  int|null $min_ts If you specify a &#39;min_ts&#39; timestamp, listens with listened_at greater than (but not including) this value will be returned. (optional)
     * @param  int|null $count Optional, number of listens to return. (optional, default to 25)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listensForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListensForUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function listensForUserWithHttpInfo($user_name, $max_ts = null, $min_ts = null, $count = 25, string $contentType = self::contentTypes['listensForUser'][0])
    {
        $request = $this->listensForUserRequest($user_name, $max_ts, $min_ts, $count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListensForUser' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListensForUser' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListensForUser', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListensForUser';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListensForUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listensForUserAsync
     *
     * Get listens for user &#39;user_name&#39;.
     *
     * @param  string $user_name (required)
     * @param  int|null $max_ts If you specify a &#39;max_ts&#39; timestamp, listens with listened_at less than (but not including) this value will be returned. (optional)
     * @param  int|null $min_ts If you specify a &#39;min_ts&#39; timestamp, listens with listened_at greater than (but not including) this value will be returned. (optional)
     * @param  int|null $count Optional, number of listens to return. (optional, default to 25)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listensForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listensForUserAsync($user_name, $max_ts = null, $min_ts = null, $count = 25, string $contentType = self::contentTypes['listensForUser'][0])
    {
        return $this->listensForUserAsyncWithHttpInfo($user_name, $max_ts, $min_ts, $count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listensForUserAsyncWithHttpInfo
     *
     * Get listens for user &#39;user_name&#39;.
     *
     * @param  string $user_name (required)
     * @param  int|null $max_ts If you specify a &#39;max_ts&#39; timestamp, listens with listened_at less than (but not including) this value will be returned. (optional)
     * @param  int|null $min_ts If you specify a &#39;min_ts&#39; timestamp, listens with listened_at greater than (but not including) this value will be returned. (optional)
     * @param  int|null $count Optional, number of listens to return. (optional, default to 25)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listensForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listensForUserAsyncWithHttpInfo($user_name, $max_ts = null, $min_ts = null, $count = 25, string $contentType = self::contentTypes['listensForUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListensForUser';
        $request = $this->listensForUserRequest($user_name, $max_ts, $min_ts, $count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listensForUser'
     *
     * @param  string $user_name (required)
     * @param  int|null $max_ts If you specify a &#39;max_ts&#39; timestamp, listens with listened_at less than (but not including) this value will be returned. (optional)
     * @param  int|null $min_ts If you specify a &#39;min_ts&#39; timestamp, listens with listened_at greater than (but not including) this value will be returned. (optional)
     * @param  int|null $count Optional, number of listens to return. (optional, default to 25)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listensForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listensForUserRequest($user_name, $max_ts = null, $min_ts = null, $count = 25, string $contentType = self::contentTypes['listensForUser'][0])
    {

        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling listensForUser'
            );
        }





        $resourcePath = '/1/user/{user_name}/listens';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ts,
            'max_ts', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_ts,
            'min_ts', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'user_name' . '}',
                ObjectSerializer::toPathValue($user_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation playingNowForUser
     *
     * Get the listen being played right now for user &#39;user_name&#39;
     *
     * @param  string $user_name user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playingNowForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PlayingNowForUser
     */
    public function playingNowForUser($user_name, string $contentType = self::contentTypes['playingNowForUser'][0])
    {
        list($response) = $this->playingNowForUserWithHttpInfo($user_name, $contentType);
        return $response;
    }

    /**
     * Operation playingNowForUserWithHttpInfo
     *
     * Get the listen being played right now for user &#39;user_name&#39;
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playingNowForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PlayingNowForUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function playingNowForUserWithHttpInfo($user_name, string $contentType = self::contentTypes['playingNowForUser'][0])
    {
        $request = $this->playingNowForUserRequest($user_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PlayingNowForUser' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PlayingNowForUser' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PlayingNowForUser', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\PlayingNowForUser';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PlayingNowForUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation playingNowForUserAsync
     *
     * Get the listen being played right now for user &#39;user_name&#39;
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playingNowForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playingNowForUserAsync($user_name, string $contentType = self::contentTypes['playingNowForUser'][0])
    {
        return $this->playingNowForUserAsyncWithHttpInfo($user_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playingNowForUserAsyncWithHttpInfo
     *
     * Get the listen being played right now for user &#39;user_name&#39;
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playingNowForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playingNowForUserAsyncWithHttpInfo($user_name, string $contentType = self::contentTypes['playingNowForUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PlayingNowForUser';
        $request = $this->playingNowForUserRequest($user_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playingNowForUser'
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playingNowForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playingNowForUserRequest($user_name, string $contentType = self::contentTypes['playingNowForUser'][0])
    {

        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling playingNowForUser'
            );
        }


        $resourcePath = '/1/user/{user_name}/playing-now';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'user_name' . '}',
                ObjectSerializer::toPathValue($user_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recommendationPlaylistsForUser
     *
     * Fetch recommendation playlist metadata in JSPF format without recordings for &#39;playlist_user_name&#39;. This endpoint only lists playlists that are to be shown on the listenbrainz.org recommendations pages.
     *
     * @param  string $playlist_user_name playlist_user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recommendationPlaylistsForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Playlists
     */
    public function recommendationPlaylistsForUser($playlist_user_name, string $contentType = self::contentTypes['recommendationPlaylistsForUser'][0])
    {
        list($response) = $this->recommendationPlaylistsForUserWithHttpInfo($playlist_user_name, $contentType);
        return $response;
    }

    /**
     * Operation recommendationPlaylistsForUserWithHttpInfo
     *
     * Fetch recommendation playlist metadata in JSPF format without recordings for &#39;playlist_user_name&#39;. This endpoint only lists playlists that are to be shown on the listenbrainz.org recommendations pages.
     *
     * @param  string $playlist_user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recommendationPlaylistsForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Playlists, HTTP status code, HTTP response headers (array of strings)
     */
    public function recommendationPlaylistsForUserWithHttpInfo($playlist_user_name, string $contentType = self::contentTypes['recommendationPlaylistsForUser'][0])
    {
        $request = $this->recommendationPlaylistsForUserRequest($playlist_user_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Playlists' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Playlists' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Playlists', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\Playlists';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Playlists',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recommendationPlaylistsForUserAsync
     *
     * Fetch recommendation playlist metadata in JSPF format without recordings for &#39;playlist_user_name&#39;. This endpoint only lists playlists that are to be shown on the listenbrainz.org recommendations pages.
     *
     * @param  string $playlist_user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recommendationPlaylistsForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recommendationPlaylistsForUserAsync($playlist_user_name, string $contentType = self::contentTypes['recommendationPlaylistsForUser'][0])
    {
        return $this->recommendationPlaylistsForUserAsyncWithHttpInfo($playlist_user_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recommendationPlaylistsForUserAsyncWithHttpInfo
     *
     * Fetch recommendation playlist metadata in JSPF format without recordings for &#39;playlist_user_name&#39;. This endpoint only lists playlists that are to be shown on the listenbrainz.org recommendations pages.
     *
     * @param  string $playlist_user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recommendationPlaylistsForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recommendationPlaylistsForUserAsyncWithHttpInfo($playlist_user_name, string $contentType = self::contentTypes['recommendationPlaylistsForUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Playlists';
        $request = $this->recommendationPlaylistsForUserRequest($playlist_user_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recommendationPlaylistsForUser'
     *
     * @param  string $playlist_user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['recommendationPlaylistsForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recommendationPlaylistsForUserRequest($playlist_user_name, string $contentType = self::contentTypes['recommendationPlaylistsForUser'][0])
    {

        // verify the required parameter 'playlist_user_name' is set
        if ($playlist_user_name === null || (is_array($playlist_user_name) && count($playlist_user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_user_name when calling recommendationPlaylistsForUser'
            );
        }


        $resourcePath = '/1/user/{playlist_user_name}/playlists/recommendations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($playlist_user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_user_name' . '}',
                ObjectSerializer::toPathValue($playlist_user_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchPlaylistForUser
     *
     * Search for a playlist by name for a user.
     *
     * @param  string $playlist_user_name playlist_user_name (required)
     * @param  string $query query (required)
     * @param  int|null $count The number of playlists to return (for pagination). (optional, default to 25)
     * @param  int|null $offset The offset of into the list of playlists to return (for pagination). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPlaylistForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Playlists
     */
    public function searchPlaylistForUser($playlist_user_name, $query, $count = 25, $offset = null, string $contentType = self::contentTypes['searchPlaylistForUser'][0])
    {
        list($response) = $this->searchPlaylistForUserWithHttpInfo($playlist_user_name, $query, $count, $offset, $contentType);
        return $response;
    }

    /**
     * Operation searchPlaylistForUserWithHttpInfo
     *
     * Search for a playlist by name for a user.
     *
     * @param  string $playlist_user_name (required)
     * @param  string $query (required)
     * @param  int|null $count The number of playlists to return (for pagination). (optional, default to 25)
     * @param  int|null $offset The offset of into the list of playlists to return (for pagination). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPlaylistForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Playlists, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchPlaylistForUserWithHttpInfo($playlist_user_name, $query, $count = 25, $offset = null, string $contentType = self::contentTypes['searchPlaylistForUser'][0])
    {
        $request = $this->searchPlaylistForUserRequest($playlist_user_name, $query, $count, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Playlists' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Playlists' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Playlists', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\Playlists';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Playlists',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchPlaylistForUserAsync
     *
     * Search for a playlist by name for a user.
     *
     * @param  string $playlist_user_name (required)
     * @param  string $query (required)
     * @param  int|null $count The number of playlists to return (for pagination). (optional, default to 25)
     * @param  int|null $offset The offset of into the list of playlists to return (for pagination). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPlaylistForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPlaylistForUserAsync($playlist_user_name, $query, $count = 25, $offset = null, string $contentType = self::contentTypes['searchPlaylistForUser'][0])
    {
        return $this->searchPlaylistForUserAsyncWithHttpInfo($playlist_user_name, $query, $count, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchPlaylistForUserAsyncWithHttpInfo
     *
     * Search for a playlist by name for a user.
     *
     * @param  string $playlist_user_name (required)
     * @param  string $query (required)
     * @param  int|null $count The number of playlists to return (for pagination). (optional, default to 25)
     * @param  int|null $offset The offset of into the list of playlists to return (for pagination). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPlaylistForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPlaylistForUserAsyncWithHttpInfo($playlist_user_name, $query, $count = 25, $offset = null, string $contentType = self::contentTypes['searchPlaylistForUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Playlists';
        $request = $this->searchPlaylistForUserRequest($playlist_user_name, $query, $count, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchPlaylistForUser'
     *
     * @param  string $playlist_user_name (required)
     * @param  string $query (required)
     * @param  int|null $count The number of playlists to return (for pagination). (optional, default to 25)
     * @param  int|null $offset The offset of into the list of playlists to return (for pagination). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPlaylistForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchPlaylistForUserRequest($playlist_user_name, $query, $count = 25, $offset = null, string $contentType = self::contentTypes['searchPlaylistForUser'][0])
    {

        // verify the required parameter 'playlist_user_name' is set
        if ($playlist_user_name === null || (is_array($playlist_user_name) && count($playlist_user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_user_name when calling searchPlaylistForUser'
            );
        }

        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchPlaylistForUser'
            );
        }




        $resourcePath = '/1/user/{playlist_user_name}/playlists/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($playlist_user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_user_name' . '}',
                ObjectSerializer::toPathValue($playlist_user_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchUsers
     *
     * Search a ListenBrainz-registered user.
     *
     * @param  string $search_term Input on which search operation is to be performed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SearchUsers
     */
    public function searchUsers($search_term, string $contentType = self::contentTypes['searchUsers'][0])
    {
        list($response) = $this->searchUsersWithHttpInfo($search_term, $contentType);
        return $response;
    }

    /**
     * Operation searchUsersWithHttpInfo
     *
     * Search a ListenBrainz-registered user.
     *
     * @param  string $search_term Input on which search operation is to be performed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SearchUsers, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchUsersWithHttpInfo($search_term, string $contentType = self::contentTypes['searchUsers'][0])
    {
        $request = $this->searchUsersRequest($search_term, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SearchUsers' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SearchUsers' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SearchUsers', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\SearchUsers';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SearchUsers',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchUsersAsync
     *
     * Search a ListenBrainz-registered user.
     *
     * @param  string $search_term Input on which search operation is to be performed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchUsersAsync($search_term, string $contentType = self::contentTypes['searchUsers'][0])
    {
        return $this->searchUsersAsyncWithHttpInfo($search_term, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchUsersAsyncWithHttpInfo
     *
     * Search a ListenBrainz-registered user.
     *
     * @param  string $search_term Input on which search operation is to be performed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchUsersAsyncWithHttpInfo($search_term, string $contentType = self::contentTypes['searchUsers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SearchUsers';
        $request = $this->searchUsersRequest($search_term, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchUsers'
     *
     * @param  string $search_term Input on which search operation is to be performed. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchUsersRequest($search_term, string $contentType = self::contentTypes['searchUsers'][0])
    {

        // verify the required parameter 'search_term' is set
        if ($search_term === null || (is_array($search_term) && count($search_term) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search_term when calling searchUsers'
            );
        }


        $resourcePath = '/1/search/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_term,
            'search_term', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation servicesForUser
     *
     * Get list of services which are connected to a given user&#39;s account.
     *
     * @param  string $user_name user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServicesForUser
     */
    public function servicesForUser($user_name, string $contentType = self::contentTypes['servicesForUser'][0])
    {
        list($response) = $this->servicesForUserWithHttpInfo($user_name, $contentType);
        return $response;
    }

    /**
     * Operation servicesForUserWithHttpInfo
     *
     * Get list of services which are connected to a given user&#39;s account.
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServicesForUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function servicesForUserWithHttpInfo($user_name, string $contentType = self::contentTypes['servicesForUser'][0])
    {
        $request = $this->servicesForUserRequest($user_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ServicesForUser' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ServicesForUser' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ServicesForUser', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ServicesForUser';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServicesForUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation servicesForUserAsync
     *
     * Get list of services which are connected to a given user&#39;s account.
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesForUserAsync($user_name, string $contentType = self::contentTypes['servicesForUser'][0])
    {
        return $this->servicesForUserAsyncWithHttpInfo($user_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation servicesForUserAsyncWithHttpInfo
     *
     * Get list of services which are connected to a given user&#39;s account.
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesForUserAsyncWithHttpInfo($user_name, string $contentType = self::contentTypes['servicesForUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServicesForUser';
        $request = $this->servicesForUserRequest($user_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'servicesForUser'
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function servicesForUserRequest($user_name, string $contentType = self::contentTypes['servicesForUser'][0])
    {

        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling servicesForUser'
            );
        }


        $resourcePath = '/1/user/{user_name}/services';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'user_name' . '}',
                ObjectSerializer::toPathValue($user_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation similarUsersForUser
     *
     * Get the listen being played right now for user &#39;user_name&#39;.
     *
     * @param  string $user_name user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['similarUsersForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SimilarUsersForUser
     */
    public function similarUsersForUser($user_name, string $contentType = self::contentTypes['similarUsersForUser'][0])
    {
        list($response) = $this->similarUsersForUserWithHttpInfo($user_name, $contentType);
        return $response;
    }

    /**
     * Operation similarUsersForUserWithHttpInfo
     *
     * Get the listen being played right now for user &#39;user_name&#39;.
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['similarUsersForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SimilarUsersForUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function similarUsersForUserWithHttpInfo($user_name, string $contentType = self::contentTypes['similarUsersForUser'][0])
    {
        $request = $this->similarUsersForUserRequest($user_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SimilarUsersForUser' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SimilarUsersForUser' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SimilarUsersForUser', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\SimilarUsersForUser';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SimilarUsersForUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation similarUsersForUserAsync
     *
     * Get the listen being played right now for user &#39;user_name&#39;.
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['similarUsersForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function similarUsersForUserAsync($user_name, string $contentType = self::contentTypes['similarUsersForUser'][0])
    {
        return $this->similarUsersForUserAsyncWithHttpInfo($user_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation similarUsersForUserAsyncWithHttpInfo
     *
     * Get the listen being played right now for user &#39;user_name&#39;.
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['similarUsersForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function similarUsersForUserAsyncWithHttpInfo($user_name, string $contentType = self::contentTypes['similarUsersForUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SimilarUsersForUser';
        $request = $this->similarUsersForUserRequest($user_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'similarUsersForUser'
     *
     * @param  string $user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['similarUsersForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function similarUsersForUserRequest($user_name, string $contentType = self::contentTypes['similarUsersForUser'][0])
    {

        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling similarUsersForUser'
            );
        }


        $resourcePath = '/1/user/{user_name}/similar-users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'user_name' . '}',
                ObjectSerializer::toPathValue($user_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation similarityOfUserForUser
     *
     * Get the similarity of &#39;user_name&#39; and &#39;other_user_name&#39;, based on their listening history.
     *
     * @param  string $user_name user_name (required)
     * @param  string $other_user_name other_user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['similarityOfUserForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SimilarityOfUserForUser
     */
    public function similarityOfUserForUser($user_name, $other_user_name, string $contentType = self::contentTypes['similarityOfUserForUser'][0])
    {
        list($response) = $this->similarityOfUserForUserWithHttpInfo($user_name, $other_user_name, $contentType);
        return $response;
    }

    /**
     * Operation similarityOfUserForUserWithHttpInfo
     *
     * Get the similarity of &#39;user_name&#39; and &#39;other_user_name&#39;, based on their listening history.
     *
     * @param  string $user_name (required)
     * @param  string $other_user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['similarityOfUserForUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SimilarityOfUserForUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function similarityOfUserForUserWithHttpInfo($user_name, $other_user_name, string $contentType = self::contentTypes['similarityOfUserForUser'][0])
    {
        $request = $this->similarityOfUserForUserRequest($user_name, $other_user_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SimilarityOfUserForUser' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SimilarityOfUserForUser' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SimilarityOfUserForUser', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\SimilarityOfUserForUser';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SimilarityOfUserForUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation similarityOfUserForUserAsync
     *
     * Get the similarity of &#39;user_name&#39; and &#39;other_user_name&#39;, based on their listening history.
     *
     * @param  string $user_name (required)
     * @param  string $other_user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['similarityOfUserForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function similarityOfUserForUserAsync($user_name, $other_user_name, string $contentType = self::contentTypes['similarityOfUserForUser'][0])
    {
        return $this->similarityOfUserForUserAsyncWithHttpInfo($user_name, $other_user_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation similarityOfUserForUserAsyncWithHttpInfo
     *
     * Get the similarity of &#39;user_name&#39; and &#39;other_user_name&#39;, based on their listening history.
     *
     * @param  string $user_name (required)
     * @param  string $other_user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['similarityOfUserForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function similarityOfUserForUserAsyncWithHttpInfo($user_name, $other_user_name, string $contentType = self::contentTypes['similarityOfUserForUser'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SimilarityOfUserForUser';
        $request = $this->similarityOfUserForUserRequest($user_name, $other_user_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'similarityOfUserForUser'
     *
     * @param  string $user_name (required)
     * @param  string $other_user_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['similarityOfUserForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function similarityOfUserForUserRequest($user_name, $other_user_name, string $contentType = self::contentTypes['similarityOfUserForUser'][0])
    {

        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling similarityOfUserForUser'
            );
        }

        // verify the required parameter 'other_user_name' is set
        if ($other_user_name === null || (is_array($other_user_name) && count($other_user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $other_user_name when calling similarityOfUserForUser'
            );
        }


        $resourcePath = '/1/user/{user_name}/similar-to/{other_user_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'user_name' . '}',
                ObjectSerializer::toPathValue($user_name),
                $resourcePath
            );
        }
        // path params
        if ($other_user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'other_user_name' . '}',
                ObjectSerializer::toPathValue($other_user_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation submitListens
     *
     * Submit listens to the server.
     *
     * @param  \OpenAPI\Client\Model\SubmitListens $submit_listens submit_listens (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitListens'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function submitListens($submit_listens, string $contentType = self::contentTypes['submitListens'][0])
    {
        $this->submitListensWithHttpInfo($submit_listens, $contentType);
    }

    /**
     * Operation submitListensWithHttpInfo
     *
     * Submit listens to the server.
     *
     * @param  \OpenAPI\Client\Model\SubmitListens $submit_listens (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitListens'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function submitListensWithHttpInfo($submit_listens, string $contentType = self::contentTypes['submitListens'][0])
    {
        $request = $this->submitListensRequest($submit_listens, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation submitListensAsync
     *
     * Submit listens to the server.
     *
     * @param  \OpenAPI\Client\Model\SubmitListens $submit_listens (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitListens'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitListensAsync($submit_listens, string $contentType = self::contentTypes['submitListens'][0])
    {
        return $this->submitListensAsyncWithHttpInfo($submit_listens, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation submitListensAsyncWithHttpInfo
     *
     * Submit listens to the server.
     *
     * @param  \OpenAPI\Client\Model\SubmitListens $submit_listens (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitListens'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitListensAsyncWithHttpInfo($submit_listens, string $contentType = self::contentTypes['submitListens'][0])
    {
        $returnType = '';
        $request = $this->submitListensRequest($submit_listens, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'submitListens'
     *
     * @param  \OpenAPI\Client\Model\SubmitListens $submit_listens (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitListens'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function submitListensRequest($submit_listens, string $contentType = self::contentTypes['submitListens'][0])
    {

        // verify the required parameter 'submit_listens' is set
        if ($submit_listens === null || (is_array($submit_listens) && count($submit_listens) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $submit_listens when calling submitListens'
            );
        }


        $resourcePath = '/1/submit-listens';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($submit_listens)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($submit_listens));
            } else {
                $httpBody = $submit_listens;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateToken
     *
     * Check whether a User Token is a valid entry in the database.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateToken'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ValidateToken
     */
    public function validateToken(string $contentType = self::contentTypes['validateToken'][0])
    {
        list($response) = $this->validateTokenWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation validateTokenWithHttpInfo
     *
     * Check whether a User Token is a valid entry in the database.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateToken'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ValidateToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateTokenWithHttpInfo(string $contentType = self::contentTypes['validateToken'][0])
    {
        $request = $this->validateTokenRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ValidateToken' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ValidateToken' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ValidateToken', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ValidateToken';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation validateTokenAsync
     *
     * Check whether a User Token is a valid entry in the database.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateTokenAsync(string $contentType = self::contentTypes['validateToken'][0])
    {
        return $this->validateTokenAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateTokenAsyncWithHttpInfo
     *
     * Check whether a User Token is a valid entry in the database.
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateTokenAsyncWithHttpInfo(string $contentType = self::contentTypes['validateToken'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ValidateToken';
        $request = $this->validateTokenRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateToken'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateTokenRequest(string $contentType = self::contentTypes['validateToken'][0])
    {


        $resourcePath = '/1/validate-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
