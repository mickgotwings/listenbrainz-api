<?php
/**
 * LbPlaylistsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Listenbrainz
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * ListenBrainz Swagger - OpenAPI 3.0
 *
 * OpenAPI client defintion.
 *
 * The version of the OpenAPI document: v-2024-07-17.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Listenbrainz\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Listenbrainz\ApiException;
use Listenbrainz\Configuration;
use Listenbrainz\HeaderSelector;
use Listenbrainz\ObjectSerializer;

/**
 * LbPlaylistsApi Class Doc Comment
 *
 * @category Class
 * @package  Listenbrainz
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class LbPlaylistsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'appendRecordings' => [
            'application/json',
        ],
        'copyPlaylist' => [
            'application/json',
        ],
        'createPlaylist' => [
            'application/json',
        ],
        'deletePlaylist' => [
            'application/json',
        ],
        'editPlaylist' => [
            'application/json',
        ],
        'fetchPlaylist' => [
            'application/json',
        ],
        'itemDelete' => [
            'application/json',
        ],
        'moveItem' => [
            'application/json',
        ],
        'playlistsCreatedForUser' => [
            'application/json',
        ],
        'playlistsForUser' => [
            'application/json',
        ],
        'playlistsForUserCollaborator' => [
            'application/json',
        ],
        'searchPlaylists' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation appendRecordings
     *
     * Append recordings to an existing playlist by posting a playlist with one of more recordings in it. The playlist must be in JSPF format with MusicBrainz extensions, which is defined here: https://musicbrainz.org/doc/jspf .  If the offset is provided in the URL, then the recordings will be added at that offset, otherwise they will be added at the end of the playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  int $offset Offset. (required)
     * @param  \Listenbrainz\Model\Playlist $playlist playlist (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['appendRecordings'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appendRecordings($playlist_mbid, $offset, $playlist, string $contentType = self::contentTypes['appendRecordings'][0])
    {
        $this->appendRecordingsWithHttpInfo($playlist_mbid, $offset, $playlist, $contentType);
    }

    /**
     * Operation appendRecordingsWithHttpInfo
     *
     * Append recordings to an existing playlist by posting a playlist with one of more recordings in it. The playlist must be in JSPF format with MusicBrainz extensions, which is defined here: https://musicbrainz.org/doc/jspf .  If the offset is provided in the URL, then the recordings will be added at that offset, otherwise they will be added at the end of the playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  int $offset Offset. (required)
     * @param  \Listenbrainz\Model\Playlist $playlist (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['appendRecordings'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appendRecordingsWithHttpInfo($playlist_mbid, $offset, $playlist, string $contentType = self::contentTypes['appendRecordings'][0])
    {
        $request = $this->appendRecordingsRequest($playlist_mbid, $offset, $playlist, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation appendRecordingsAsync
     *
     * Append recordings to an existing playlist by posting a playlist with one of more recordings in it. The playlist must be in JSPF format with MusicBrainz extensions, which is defined here: https://musicbrainz.org/doc/jspf .  If the offset is provided in the URL, then the recordings will be added at that offset, otherwise they will be added at the end of the playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  int $offset Offset. (required)
     * @param  \Listenbrainz\Model\Playlist $playlist (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['appendRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appendRecordingsAsync($playlist_mbid, $offset, $playlist, string $contentType = self::contentTypes['appendRecordings'][0])
    {
        return $this->appendRecordingsAsyncWithHttpInfo($playlist_mbid, $offset, $playlist, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appendRecordingsAsyncWithHttpInfo
     *
     * Append recordings to an existing playlist by posting a playlist with one of more recordings in it. The playlist must be in JSPF format with MusicBrainz extensions, which is defined here: https://musicbrainz.org/doc/jspf .  If the offset is provided in the URL, then the recordings will be added at that offset, otherwise they will be added at the end of the playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  int $offset Offset. (required)
     * @param  \Listenbrainz\Model\Playlist $playlist (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['appendRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appendRecordingsAsyncWithHttpInfo($playlist_mbid, $offset, $playlist, string $contentType = self::contentTypes['appendRecordings'][0])
    {
        $returnType = '';
        $request = $this->appendRecordingsRequest($playlist_mbid, $offset, $playlist, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appendRecordings'
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  int $offset Offset. (required)
     * @param  \Listenbrainz\Model\Playlist $playlist (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['appendRecordings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function appendRecordingsRequest($playlist_mbid, $offset, $playlist, string $contentType = self::contentTypes['appendRecordings'][0])
    {

        // verify the required parameter 'playlist_mbid' is set
        if ($playlist_mbid === null || (is_array($playlist_mbid) && count($playlist_mbid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_mbid when calling appendRecordings'
            );
        }

        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling appendRecordings'
            );
        }

        // verify the required parameter 'playlist' is set
        if ($playlist === null || (is_array($playlist) && count($playlist) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist when calling appendRecordings'
            );
        }


        $resourcePath = '/1/playlist/{playlist_mbid}/item/add/{offset}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($playlist_mbid !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_mbid' . '}',
                ObjectSerializer::toPathValue($playlist_mbid),
                $resourcePath
            );
        }
        // path params
        if ($offset !== null) {
            $resourcePath = str_replace(
                '{' . 'offset' . '}',
                ObjectSerializer::toPathValue($offset),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($playlist)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($playlist));
            } else {
                $httpBody = $playlist;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyPlaylist
     *
     * Copy a playlist - the new playlist will be given the name “Copy of &lt;playlist_name&gt;”. POST body data does not need to contain anything.
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyPlaylist'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function copyPlaylist($playlist_mbid, string $contentType = self::contentTypes['copyPlaylist'][0])
    {
        $this->copyPlaylistWithHttpInfo($playlist_mbid, $contentType);
    }

    /**
     * Operation copyPlaylistWithHttpInfo
     *
     * Copy a playlist - the new playlist will be given the name “Copy of &lt;playlist_name&gt;”. POST body data does not need to contain anything.
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyPlaylist'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyPlaylistWithHttpInfo($playlist_mbid, string $contentType = self::contentTypes['copyPlaylist'][0])
    {
        $request = $this->copyPlaylistRequest($playlist_mbid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation copyPlaylistAsync
     *
     * Copy a playlist - the new playlist will be given the name “Copy of &lt;playlist_name&gt;”. POST body data does not need to contain anything.
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyPlaylistAsync($playlist_mbid, string $contentType = self::contentTypes['copyPlaylist'][0])
    {
        return $this->copyPlaylistAsyncWithHttpInfo($playlist_mbid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyPlaylistAsyncWithHttpInfo
     *
     * Copy a playlist - the new playlist will be given the name “Copy of &lt;playlist_name&gt;”. POST body data does not need to contain anything.
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyPlaylistAsyncWithHttpInfo($playlist_mbid, string $contentType = self::contentTypes['copyPlaylist'][0])
    {
        $returnType = '';
        $request = $this->copyPlaylistRequest($playlist_mbid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyPlaylist'
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function copyPlaylistRequest($playlist_mbid, string $contentType = self::contentTypes['copyPlaylist'][0])
    {

        // verify the required parameter 'playlist_mbid' is set
        if ($playlist_mbid === null || (is_array($playlist_mbid) && count($playlist_mbid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_mbid when calling copyPlaylist'
            );
        }


        $resourcePath = '/1/playlist/{playlist_mbid}/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($playlist_mbid !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_mbid' . '}',
                ObjectSerializer::toPathValue($playlist_mbid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPlaylist
     *
     * Create a playlist
     *
     * @param  \Listenbrainz\Model\CreatePlaylistRequest $create_playlist_request create_playlist_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPlaylist'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Listenbrainz\Model\CreatePlaylist200Response
     */
    public function createPlaylist($create_playlist_request, string $contentType = self::contentTypes['createPlaylist'][0])
    {
        list($response) = $this->createPlaylistWithHttpInfo($create_playlist_request, $contentType);
        return $response;
    }

    /**
     * Operation createPlaylistWithHttpInfo
     *
     * Create a playlist
     *
     * @param  \Listenbrainz\Model\CreatePlaylistRequest $create_playlist_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPlaylist'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Listenbrainz\Model\CreatePlaylist200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPlaylistWithHttpInfo($create_playlist_request, string $contentType = self::contentTypes['createPlaylist'][0])
    {
        $request = $this->createPlaylistRequest($create_playlist_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Listenbrainz\Model\CreatePlaylist200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Listenbrainz\Model\CreatePlaylist200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Listenbrainz\Model\CreatePlaylist200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Listenbrainz\Model\CreatePlaylist200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listenbrainz\Model\CreatePlaylist200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPlaylistAsync
     *
     * Create a playlist
     *
     * @param  \Listenbrainz\Model\CreatePlaylistRequest $create_playlist_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPlaylistAsync($create_playlist_request, string $contentType = self::contentTypes['createPlaylist'][0])
    {
        return $this->createPlaylistAsyncWithHttpInfo($create_playlist_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPlaylistAsyncWithHttpInfo
     *
     * Create a playlist
     *
     * @param  \Listenbrainz\Model\CreatePlaylistRequest $create_playlist_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPlaylistAsyncWithHttpInfo($create_playlist_request, string $contentType = self::contentTypes['createPlaylist'][0])
    {
        $returnType = '\Listenbrainz\Model\CreatePlaylist200Response';
        $request = $this->createPlaylistRequest($create_playlist_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPlaylist'
     *
     * @param  \Listenbrainz\Model\CreatePlaylistRequest $create_playlist_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createPlaylistRequest($create_playlist_request, string $contentType = self::contentTypes['createPlaylist'][0])
    {

        // verify the required parameter 'create_playlist_request' is set
        if ($create_playlist_request === null || (is_array($create_playlist_request) && count($create_playlist_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_playlist_request when calling createPlaylist'
            );
        }


        $resourcePath = '/1/playlist/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_playlist_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_playlist_request));
            } else {
                $httpBody = $create_playlist_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePlaylist
     *
     * Delete a playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePlaylist'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePlaylist($playlist_mbid, string $contentType = self::contentTypes['deletePlaylist'][0])
    {
        $this->deletePlaylistWithHttpInfo($playlist_mbid, $contentType);
    }

    /**
     * Operation deletePlaylistWithHttpInfo
     *
     * Delete a playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePlaylist'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePlaylistWithHttpInfo($playlist_mbid, string $contentType = self::contentTypes['deletePlaylist'][0])
    {
        $request = $this->deletePlaylistRequest($playlist_mbid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePlaylistAsync
     *
     * Delete a playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePlaylistAsync($playlist_mbid, string $contentType = self::contentTypes['deletePlaylist'][0])
    {
        return $this->deletePlaylistAsyncWithHttpInfo($playlist_mbid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePlaylistAsyncWithHttpInfo
     *
     * Delete a playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePlaylistAsyncWithHttpInfo($playlist_mbid, string $contentType = self::contentTypes['deletePlaylist'][0])
    {
        $returnType = '';
        $request = $this->deletePlaylistRequest($playlist_mbid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePlaylist'
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deletePlaylistRequest($playlist_mbid, string $contentType = self::contentTypes['deletePlaylist'][0])
    {

        // verify the required parameter 'playlist_mbid' is set
        if ($playlist_mbid === null || (is_array($playlist_mbid) && count($playlist_mbid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_mbid when calling deletePlaylist'
            );
        }


        $resourcePath = '/1/playlist/{playlist_mbid}/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($playlist_mbid !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_mbid' . '}',
                ObjectSerializer::toPathValue($playlist_mbid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editPlaylist
     *
     * Create a playlist. The playlist must be in JSPF format with MusicBrainz extensions, which is defined here: https://musicbrainz.org/doc/jspf . To create an empty playlist, you can send an empty playlist with only the title field filled out. If you would like to create a playlist populated with recordings, each of the track items in the playlist must have an identifier element that contains the MusicBrainz recording that includes the recording MBID.  When creating a playlist, only the playlist title and the track identifier elements will be used - all other elements in the posted JSPF wil be ignored.  If a created_for field is found and the user is not an approved playlist bot, then a 403 forbidden will be raised.
     *
     * @param  string $playlist_mbid The playlist mbid to edit. (required)
     * @param  \Listenbrainz\Model\CreatePlaylistRequest $create_playlist_request create_playlist_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['editPlaylist'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function editPlaylist($playlist_mbid, $create_playlist_request, string $contentType = self::contentTypes['editPlaylist'][0])
    {
        $this->editPlaylistWithHttpInfo($playlist_mbid, $create_playlist_request, $contentType);
    }

    /**
     * Operation editPlaylistWithHttpInfo
     *
     * Create a playlist. The playlist must be in JSPF format with MusicBrainz extensions, which is defined here: https://musicbrainz.org/doc/jspf . To create an empty playlist, you can send an empty playlist with only the title field filled out. If you would like to create a playlist populated with recordings, each of the track items in the playlist must have an identifier element that contains the MusicBrainz recording that includes the recording MBID.  When creating a playlist, only the playlist title and the track identifier elements will be used - all other elements in the posted JSPF wil be ignored.  If a created_for field is found and the user is not an approved playlist bot, then a 403 forbidden will be raised.
     *
     * @param  string $playlist_mbid The playlist mbid to edit. (required)
     * @param  \Listenbrainz\Model\CreatePlaylistRequest $create_playlist_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['editPlaylist'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function editPlaylistWithHttpInfo($playlist_mbid, $create_playlist_request, string $contentType = self::contentTypes['editPlaylist'][0])
    {
        $request = $this->editPlaylistRequest($playlist_mbid, $create_playlist_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation editPlaylistAsync
     *
     * Create a playlist. The playlist must be in JSPF format with MusicBrainz extensions, which is defined here: https://musicbrainz.org/doc/jspf . To create an empty playlist, you can send an empty playlist with only the title field filled out. If you would like to create a playlist populated with recordings, each of the track items in the playlist must have an identifier element that contains the MusicBrainz recording that includes the recording MBID.  When creating a playlist, only the playlist title and the track identifier elements will be used - all other elements in the posted JSPF wil be ignored.  If a created_for field is found and the user is not an approved playlist bot, then a 403 forbidden will be raised.
     *
     * @param  string $playlist_mbid The playlist mbid to edit. (required)
     * @param  \Listenbrainz\Model\CreatePlaylistRequest $create_playlist_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['editPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editPlaylistAsync($playlist_mbid, $create_playlist_request, string $contentType = self::contentTypes['editPlaylist'][0])
    {
        return $this->editPlaylistAsyncWithHttpInfo($playlist_mbid, $create_playlist_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editPlaylistAsyncWithHttpInfo
     *
     * Create a playlist. The playlist must be in JSPF format with MusicBrainz extensions, which is defined here: https://musicbrainz.org/doc/jspf . To create an empty playlist, you can send an empty playlist with only the title field filled out. If you would like to create a playlist populated with recordings, each of the track items in the playlist must have an identifier element that contains the MusicBrainz recording that includes the recording MBID.  When creating a playlist, only the playlist title and the track identifier elements will be used - all other elements in the posted JSPF wil be ignored.  If a created_for field is found and the user is not an approved playlist bot, then a 403 forbidden will be raised.
     *
     * @param  string $playlist_mbid The playlist mbid to edit. (required)
     * @param  \Listenbrainz\Model\CreatePlaylistRequest $create_playlist_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['editPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editPlaylistAsyncWithHttpInfo($playlist_mbid, $create_playlist_request, string $contentType = self::contentTypes['editPlaylist'][0])
    {
        $returnType = '';
        $request = $this->editPlaylistRequest($playlist_mbid, $create_playlist_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editPlaylist'
     *
     * @param  string $playlist_mbid The playlist mbid to edit. (required)
     * @param  \Listenbrainz\Model\CreatePlaylistRequest $create_playlist_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['editPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function editPlaylistRequest($playlist_mbid, $create_playlist_request, string $contentType = self::contentTypes['editPlaylist'][0])
    {

        // verify the required parameter 'playlist_mbid' is set
        if ($playlist_mbid === null || (is_array($playlist_mbid) && count($playlist_mbid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_mbid when calling editPlaylist'
            );
        }

        // verify the required parameter 'create_playlist_request' is set
        if ($create_playlist_request === null || (is_array($create_playlist_request) && count($create_playlist_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_playlist_request when calling editPlaylist'
            );
        }


        $resourcePath = '/1/playlist/edit/{playlist_mbid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($playlist_mbid !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_mbid' . '}',
                ObjectSerializer::toPathValue($playlist_mbid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_playlist_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_playlist_request));
            } else {
                $httpBody = $create_playlist_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fetchPlaylist
     *
     * Fetch the given playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  bool|null $fetch_metadata Optional, pass value ‘false&#39; to skip lookup up recording metadata. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchPlaylist'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Listenbrainz\Model\CreatePlaylistRequest
     */
    public function fetchPlaylist($playlist_mbid, $fetch_metadata = null, string $contentType = self::contentTypes['fetchPlaylist'][0])
    {
        list($response) = $this->fetchPlaylistWithHttpInfo($playlist_mbid, $fetch_metadata, $contentType);
        return $response;
    }

    /**
     * Operation fetchPlaylistWithHttpInfo
     *
     * Fetch the given playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  bool|null $fetch_metadata Optional, pass value ‘false&#39; to skip lookup up recording metadata. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchPlaylist'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Listenbrainz\Model\CreatePlaylistRequest, HTTP status code, HTTP response headers (array of strings)
     */
    public function fetchPlaylistWithHttpInfo($playlist_mbid, $fetch_metadata = null, string $contentType = self::contentTypes['fetchPlaylist'][0])
    {
        $request = $this->fetchPlaylistRequest($playlist_mbid, $fetch_metadata, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Listenbrainz\Model\CreatePlaylistRequest' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Listenbrainz\Model\CreatePlaylistRequest' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Listenbrainz\Model\CreatePlaylistRequest', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Listenbrainz\Model\CreatePlaylistRequest';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listenbrainz\Model\CreatePlaylistRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fetchPlaylistAsync
     *
     * Fetch the given playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  bool|null $fetch_metadata Optional, pass value ‘false&#39; to skip lookup up recording metadata. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchPlaylistAsync($playlist_mbid, $fetch_metadata = null, string $contentType = self::contentTypes['fetchPlaylist'][0])
    {
        return $this->fetchPlaylistAsyncWithHttpInfo($playlist_mbid, $fetch_metadata, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fetchPlaylistAsyncWithHttpInfo
     *
     * Fetch the given playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  bool|null $fetch_metadata Optional, pass value ‘false&#39; to skip lookup up recording metadata. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchPlaylistAsyncWithHttpInfo($playlist_mbid, $fetch_metadata = null, string $contentType = self::contentTypes['fetchPlaylist'][0])
    {
        $returnType = '\Listenbrainz\Model\CreatePlaylistRequest';
        $request = $this->fetchPlaylistRequest($playlist_mbid, $fetch_metadata, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fetchPlaylist'
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  bool|null $fetch_metadata Optional, pass value ‘false&#39; to skip lookup up recording metadata. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchPlaylist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fetchPlaylistRequest($playlist_mbid, $fetch_metadata = null, string $contentType = self::contentTypes['fetchPlaylist'][0])
    {

        // verify the required parameter 'playlist_mbid' is set
        if ($playlist_mbid === null || (is_array($playlist_mbid) && count($playlist_mbid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_mbid when calling fetchPlaylist'
            );
        }



        $resourcePath = '/1/playlist/{playlist_mbid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fetch_metadata,
            'fetch_metadata', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($playlist_mbid !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_mbid' . '}',
                ObjectSerializer::toPathValue($playlist_mbid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation itemDelete
     *
     * Delete an item in a playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  \Listenbrainz\Model\ItemDeleteRequest $item_delete_request item_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemDelete'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function itemDelete($playlist_mbid, $item_delete_request, string $contentType = self::contentTypes['itemDelete'][0])
    {
        $this->itemDeleteWithHttpInfo($playlist_mbid, $item_delete_request, $contentType);
    }

    /**
     * Operation itemDeleteWithHttpInfo
     *
     * Delete an item in a playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  \Listenbrainz\Model\ItemDeleteRequest $item_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemDelete'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function itemDeleteWithHttpInfo($playlist_mbid, $item_delete_request, string $contentType = self::contentTypes['itemDelete'][0])
    {
        $request = $this->itemDeleteRequest($playlist_mbid, $item_delete_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation itemDeleteAsync
     *
     * Delete an item in a playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  \Listenbrainz\Model\ItemDeleteRequest $item_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function itemDeleteAsync($playlist_mbid, $item_delete_request, string $contentType = self::contentTypes['itemDelete'][0])
    {
        return $this->itemDeleteAsyncWithHttpInfo($playlist_mbid, $item_delete_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation itemDeleteAsyncWithHttpInfo
     *
     * Delete an item in a playlist.
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  \Listenbrainz\Model\ItemDeleteRequest $item_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function itemDeleteAsyncWithHttpInfo($playlist_mbid, $item_delete_request, string $contentType = self::contentTypes['itemDelete'][0])
    {
        $returnType = '';
        $request = $this->itemDeleteRequest($playlist_mbid, $item_delete_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'itemDelete'
     *
     * @param  string $playlist_mbid The playlist mbid to fetch. (required)
     * @param  \Listenbrainz\Model\ItemDeleteRequest $item_delete_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function itemDeleteRequest($playlist_mbid, $item_delete_request, string $contentType = self::contentTypes['itemDelete'][0])
    {

        // verify the required parameter 'playlist_mbid' is set
        if ($playlist_mbid === null || (is_array($playlist_mbid) && count($playlist_mbid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_mbid when calling itemDelete'
            );
        }

        // verify the required parameter 'item_delete_request' is set
        if ($item_delete_request === null || (is_array($item_delete_request) && count($item_delete_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_delete_request when calling itemDelete'
            );
        }


        $resourcePath = '/1/playlist/{playlist_mbid}/item/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($playlist_mbid !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_mbid' . '}',
                ObjectSerializer::toPathValue($playlist_mbid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($item_delete_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($item_delete_request));
            } else {
                $httpBody = $item_delete_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation moveItem
     *
     * To move an item in a playlist, the POST data needs to specify the recording MBID and current index of the track to move (from), where to move it to (to) and how many tracks from that position should be moved (count).
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  \Listenbrainz\Model\MoveItemRequest $move_item_request move_item_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveItem'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function moveItem($playlist_mbid, $move_item_request, string $contentType = self::contentTypes['moveItem'][0])
    {
        $this->moveItemWithHttpInfo($playlist_mbid, $move_item_request, $contentType);
    }

    /**
     * Operation moveItemWithHttpInfo
     *
     * To move an item in a playlist, the POST data needs to specify the recording MBID and current index of the track to move (from), where to move it to (to) and how many tracks from that position should be moved (count).
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  \Listenbrainz\Model\MoveItemRequest $move_item_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveItem'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function moveItemWithHttpInfo($playlist_mbid, $move_item_request, string $contentType = self::contentTypes['moveItem'][0])
    {
        $request = $this->moveItemRequest($playlist_mbid, $move_item_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation moveItemAsync
     *
     * To move an item in a playlist, the POST data needs to specify the recording MBID and current index of the track to move (from), where to move it to (to) and how many tracks from that position should be moved (count).
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  \Listenbrainz\Model\MoveItemRequest $move_item_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveItemAsync($playlist_mbid, $move_item_request, string $contentType = self::contentTypes['moveItem'][0])
    {
        return $this->moveItemAsyncWithHttpInfo($playlist_mbid, $move_item_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation moveItemAsyncWithHttpInfo
     *
     * To move an item in a playlist, the POST data needs to specify the recording MBID and current index of the track to move (from), where to move it to (to) and how many tracks from that position should be moved (count).
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  \Listenbrainz\Model\MoveItemRequest $move_item_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveItemAsyncWithHttpInfo($playlist_mbid, $move_item_request, string $contentType = self::contentTypes['moveItem'][0])
    {
        $returnType = '';
        $request = $this->moveItemRequest($playlist_mbid, $move_item_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'moveItem'
     *
     * @param  string $playlist_mbid The playlist mbid to append to. (required)
     * @param  \Listenbrainz\Model\MoveItemRequest $move_item_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function moveItemRequest($playlist_mbid, $move_item_request, string $contentType = self::contentTypes['moveItem'][0])
    {

        // verify the required parameter 'playlist_mbid' is set
        if ($playlist_mbid === null || (is_array($playlist_mbid) && count($playlist_mbid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_mbid when calling moveItem'
            );
        }

        // verify the required parameter 'move_item_request' is set
        if ($move_item_request === null || (is_array($move_item_request) && count($move_item_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $move_item_request when calling moveItem'
            );
        }


        $resourcePath = '/1/playlist/{playlist_mbid}/item/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($playlist_mbid !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_mbid' . '}',
                ObjectSerializer::toPathValue($playlist_mbid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($move_item_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($move_item_request));
            } else {
                $httpBody = $move_item_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation playlistsCreatedForUser
     *
     * Fetch playlist metadata in JSPF format without recordings that have been created for the user.
     *
     * @param  string $playlist_user_name playlist_user_name (required)
     * @param  int|null $count count (optional, default to 25)
     * @param  int|null $offset offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsCreatedForUser'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Listenbrainz\Model\Playlists
     */
    public function playlistsCreatedForUser($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsCreatedForUser'][0])
    {
        list($response) = $this->playlistsCreatedForUserWithHttpInfo($playlist_user_name, $count, $offset, $contentType);
        return $response;
    }

    /**
     * Operation playlistsCreatedForUserWithHttpInfo
     *
     * Fetch playlist metadata in JSPF format without recordings that have been created for the user.
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsCreatedForUser'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Listenbrainz\Model\Playlists, HTTP status code, HTTP response headers (array of strings)
     */
    public function playlistsCreatedForUserWithHttpInfo($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsCreatedForUser'][0])
    {
        $request = $this->playlistsCreatedForUserRequest($playlist_user_name, $count, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Listenbrainz\Model\Playlists' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Listenbrainz\Model\Playlists' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Listenbrainz\Model\Playlists', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Listenbrainz\Model\Playlists';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listenbrainz\Model\Playlists',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation playlistsCreatedForUserAsync
     *
     * Fetch playlist metadata in JSPF format without recordings that have been created for the user.
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsCreatedForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playlistsCreatedForUserAsync($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsCreatedForUser'][0])
    {
        return $this->playlistsCreatedForUserAsyncWithHttpInfo($playlist_user_name, $count, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playlistsCreatedForUserAsyncWithHttpInfo
     *
     * Fetch playlist metadata in JSPF format without recordings that have been created for the user.
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsCreatedForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playlistsCreatedForUserAsyncWithHttpInfo($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsCreatedForUser'][0])
    {
        $returnType = '\Listenbrainz\Model\Playlists';
        $request = $this->playlistsCreatedForUserRequest($playlist_user_name, $count, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playlistsCreatedForUser'
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsCreatedForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playlistsCreatedForUserRequest($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsCreatedForUser'][0])
    {

        // verify the required parameter 'playlist_user_name' is set
        if ($playlist_user_name === null || (is_array($playlist_user_name) && count($playlist_user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_user_name when calling playlistsCreatedForUser'
            );
        }




        $resourcePath = '/1/user/{playlist_user_name}/playlists/createdfor';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($playlist_user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_user_name' . '}',
                ObjectSerializer::toPathValue($playlist_user_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation playlistsForUser
     *
     * Fetch playlist metadata in JSPF format without recordings for the given user.
     *
     * @param  string $playlist_user_name playlist_user_name (required)
     * @param  int|null $count count (optional, default to 25)
     * @param  int|null $offset offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsForUser'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Listenbrainz\Model\Playlists
     */
    public function playlistsForUser($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsForUser'][0])
    {
        list($response) = $this->playlistsForUserWithHttpInfo($playlist_user_name, $count, $offset, $contentType);
        return $response;
    }

    /**
     * Operation playlistsForUserWithHttpInfo
     *
     * Fetch playlist metadata in JSPF format without recordings for the given user.
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsForUser'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Listenbrainz\Model\Playlists, HTTP status code, HTTP response headers (array of strings)
     */
    public function playlistsForUserWithHttpInfo($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsForUser'][0])
    {
        $request = $this->playlistsForUserRequest($playlist_user_name, $count, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Listenbrainz\Model\Playlists' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Listenbrainz\Model\Playlists' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Listenbrainz\Model\Playlists', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Listenbrainz\Model\Playlists';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listenbrainz\Model\Playlists',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation playlistsForUserAsync
     *
     * Fetch playlist metadata in JSPF format without recordings for the given user.
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playlistsForUserAsync($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsForUser'][0])
    {
        return $this->playlistsForUserAsyncWithHttpInfo($playlist_user_name, $count, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playlistsForUserAsyncWithHttpInfo
     *
     * Fetch playlist metadata in JSPF format without recordings for the given user.
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playlistsForUserAsyncWithHttpInfo($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsForUser'][0])
    {
        $returnType = '\Listenbrainz\Model\Playlists';
        $request = $this->playlistsForUserRequest($playlist_user_name, $count, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playlistsForUser'
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playlistsForUserRequest($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsForUser'][0])
    {

        // verify the required parameter 'playlist_user_name' is set
        if ($playlist_user_name === null || (is_array($playlist_user_name) && count($playlist_user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_user_name when calling playlistsForUser'
            );
        }




        $resourcePath = '/1/user/{playlist_user_name}/playlists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($playlist_user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_user_name' . '}',
                ObjectSerializer::toPathValue($playlist_user_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation playlistsForUserCollaborator
     *
     * Fetch playlist metadata in JSPF format without recordings for which a user is a collaborator. If a playlist is private, it will only be returned if the caller is authorized to edit that playlist.
     *
     * @param  string $playlist_user_name playlist_user_name (required)
     * @param  int|null $count count (optional, default to 25)
     * @param  int|null $offset offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsForUserCollaborator'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Listenbrainz\Model\Playlists
     */
    public function playlistsForUserCollaborator($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsForUserCollaborator'][0])
    {
        list($response) = $this->playlistsForUserCollaboratorWithHttpInfo($playlist_user_name, $count, $offset, $contentType);
        return $response;
    }

    /**
     * Operation playlistsForUserCollaboratorWithHttpInfo
     *
     * Fetch playlist metadata in JSPF format without recordings for which a user is a collaborator. If a playlist is private, it will only be returned if the caller is authorized to edit that playlist.
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsForUserCollaborator'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Listenbrainz\Model\Playlists, HTTP status code, HTTP response headers (array of strings)
     */
    public function playlistsForUserCollaboratorWithHttpInfo($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsForUserCollaborator'][0])
    {
        $request = $this->playlistsForUserCollaboratorRequest($playlist_user_name, $count, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Listenbrainz\Model\Playlists' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Listenbrainz\Model\Playlists' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Listenbrainz\Model\Playlists', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Listenbrainz\Model\Playlists';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listenbrainz\Model\Playlists',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation playlistsForUserCollaboratorAsync
     *
     * Fetch playlist metadata in JSPF format without recordings for which a user is a collaborator. If a playlist is private, it will only be returned if the caller is authorized to edit that playlist.
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsForUserCollaborator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playlistsForUserCollaboratorAsync($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsForUserCollaborator'][0])
    {
        return $this->playlistsForUserCollaboratorAsyncWithHttpInfo($playlist_user_name, $count, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playlistsForUserCollaboratorAsyncWithHttpInfo
     *
     * Fetch playlist metadata in JSPF format without recordings for which a user is a collaborator. If a playlist is private, it will only be returned if the caller is authorized to edit that playlist.
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsForUserCollaborator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playlistsForUserCollaboratorAsyncWithHttpInfo($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsForUserCollaborator'][0])
    {
        $returnType = '\Listenbrainz\Model\Playlists';
        $request = $this->playlistsForUserCollaboratorRequest($playlist_user_name, $count, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playlistsForUserCollaborator'
     *
     * @param  string $playlist_user_name (required)
     * @param  int|null $count (optional, default to 25)
     * @param  int|null $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playlistsForUserCollaborator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playlistsForUserCollaboratorRequest($playlist_user_name, $count = 25, $offset = null, string $contentType = self::contentTypes['playlistsForUserCollaborator'][0])
    {

        // verify the required parameter 'playlist_user_name' is set
        if ($playlist_user_name === null || (is_array($playlist_user_name) && count($playlist_user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playlist_user_name when calling playlistsForUserCollaborator'
            );
        }




        $resourcePath = '/1/user/{playlist_user_name}/playlists/collaborator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($playlist_user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'playlist_user_name' . '}',
                ObjectSerializer::toPathValue($playlist_user_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchPlaylists
     *
     * Search for playlists by name or description. The search query must be at least 3 characters long.
     *
     * @param  string $query query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPlaylists'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Listenbrainz\Model\Playlists
     */
    public function searchPlaylists($query, string $contentType = self::contentTypes['searchPlaylists'][0])
    {
        list($response) = $this->searchPlaylistsWithHttpInfo($query, $contentType);
        return $response;
    }

    /**
     * Operation searchPlaylistsWithHttpInfo
     *
     * Search for playlists by name or description. The search query must be at least 3 characters long.
     *
     * @param  string $query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPlaylists'] to see the possible values for this operation
     *
     * @throws \Listenbrainz\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Listenbrainz\Model\Playlists, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchPlaylistsWithHttpInfo($query, string $contentType = self::contentTypes['searchPlaylists'][0])
    {
        $request = $this->searchPlaylistsRequest($query, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Listenbrainz\Model\Playlists' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Listenbrainz\Model\Playlists' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Listenbrainz\Model\Playlists', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Listenbrainz\Model\Playlists';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Listenbrainz\Model\Playlists',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchPlaylistsAsync
     *
     * Search for playlists by name or description. The search query must be at least 3 characters long.
     *
     * @param  string $query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPlaylists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPlaylistsAsync($query, string $contentType = self::contentTypes['searchPlaylists'][0])
    {
        return $this->searchPlaylistsAsyncWithHttpInfo($query, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchPlaylistsAsyncWithHttpInfo
     *
     * Search for playlists by name or description. The search query must be at least 3 characters long.
     *
     * @param  string $query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPlaylists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPlaylistsAsyncWithHttpInfo($query, string $contentType = self::contentTypes['searchPlaylists'][0])
    {
        $returnType = '\Listenbrainz\Model\Playlists';
        $request = $this->searchPlaylistsRequest($query, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchPlaylists'
     *
     * @param  string $query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchPlaylists'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchPlaylistsRequest($query, string $contentType = self::contentTypes['searchPlaylists'][0])
    {

        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchPlaylists'
            );
        }


        $resourcePath = '/1/playlist/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
